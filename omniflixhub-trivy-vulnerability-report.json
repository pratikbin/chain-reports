{
  "SchemaVersion": 2,
  "ArtifactName": "omniflixhub_v0.11.1",
  "ArtifactType": "container_image",
  "Metadata": {
    "ImageID": "sha256:402b6df36eaf34df454de73c8446e48949734146874357ae377efab11b679dff",
    "DiffIDs": [
      "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
    ],
    "ImageConfig": {
      "architecture": "amd64",
      "created": "2023-06-23T12:40:33.471977367Z",
      "history": [
        {
          "created": "2023-06-23T12:40:33.471977367Z",
          "created_by": "COPY /bin/omniflixhubd /bin/omniflixhubd # buildkit",
          "comment": "buildkit.dockerfile.v0"
        }
      ],
      "os": "linux",
      "rootfs": {
        "type": "layers",
        "diff_ids": [
          "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
        ]
      },
      "config": {
        "Env": [
          "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        ],
        "WorkingDir": "/"
      }
    }
  },
  "Results": [
    {
      "Target": "bin/omniflixhubd",
      "Class": "lang-pkgs",
      "Type": "gobinary",
      "Vulnerabilities": [
        {
          "VulnerabilityID": "CVE-2023-34451",
          "PkgName": "github.com/cometbft/cometbft",
          "InstalledVersion": "v0.34.28",
          "FixedVersion": "0.37.2, 0.34.29",
          "Layer": {
            "Digest": "sha256:b8a1780f82ad325be555dca397d200f52a967c999847eaf12cd6c3d0f2013ee9",
            "DiffID": "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
          },
          "SeveritySource": "ghsa",
          "PrimaryURL": "https://avd.aquasec.com/nvd/cve-2023-34451",
          "DataSource": {
            "ID": "ghsa",
            "Name": "GitHub Security Advisory Go",
            "URL": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"
          },
          "Title": "CometBFT may duplicate transactions in the mempool's data structures",
          "Description": "CometBFT is a Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine and replicates it on many machines. The mempool maintains two data structures to keep track of outstanding transactions: a list and a map.\nThese two data structures are supposed to be in sync all the time in the sense that the map tracks the index (if any) of the transaction in the list. In `v0.37.0`, and `v0.37.1`, as well as in `v0.34.28`, and all previous releases of the CometBFT repo2, it is possible to have them out of sync. When this happens, the list may contain several copies of the same transaction. Because the map tracks a single index, it is then no longer possible to remove all the copies of the transaction from the list. This happens even if the duplicated transaction is later committed in a block. The only way to remove the transaction is by restarting the node.\n\nThe above problem can be repeated on and on until a sizable number of transactions are stuck in the mempool, in order to try to bring down the target node. The problem is fixed in releases `v0.34.29` and `v0.37.2`. Some workarounds are available. Increasing the value of `cache_size` in `config.toml` makes it very difficult to effectively attack a full node. Not exposing the transaction submission RPC's would mitigate the probability of a successful attack, as the attacker would then have to create a modified (byzantine) full node to be able to perform the attack via p2p.",
          "Severity": "HIGH",
          "CweIDs": [
            "CWE-401"
          ],
          "CVSS": {
            "ghsa": {
              "V3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H",
              "V3Score": 8.2
            },
            "nvd": {
              "V3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H",
              "V3Score": 8.2
            }
          },
          "References": [
            "https://github.com/advisories/GHSA-w24w-wp77-qffm",
            "https://github.com/cometbft/cometbft/pull/890",
            "https://github.com/cometbft/cometbft/security/advisories/GHSA-w24w-wp77-qffm",
            "https://github.com/tendermint/tendermint/pull/2778",
            "https://nvd.nist.gov/vuln/detail/CVE-2023-34451"
          ],
          "PublishedDate": "2023-07-03T17:15:00Z",
          "LastModifiedDate": "2023-07-17T18:58:00Z"
        },
        {
          "VulnerabilityID": "CVE-2023-34450",
          "PkgName": "github.com/cometbft/cometbft",
          "InstalledVersion": "v0.34.28",
          "FixedVersion": "0.37.2, 0.34.29",
          "Layer": {
            "Digest": "sha256:b8a1780f82ad325be555dca397d200f52a967c999847eaf12cd6c3d0f2013ee9",
            "DiffID": "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
          },
          "SeveritySource": "ghsa",
          "PrimaryURL": "https://avd.aquasec.com/nvd/cve-2023-34450",
          "DataSource": {
            "ID": "ghsa",
            "Name": "GitHub Security Advisory Go",
            "URL": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"
          },
          "Title": "CometBFT PeerState JSON serialization deadlock",
          "Description": "CometBFT is a Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine and replicates it on many machines. An internal modification made in versions 0.34.28 and 0.37.1 to the way struct `PeerState` is serialized to JSON introduced a deadlock when new function MarshallJSON is called. This function can be called from two places. The first is via logs, setting the `consensus` logging module to \"debug\" level (should not happen in production), and setting the log output format to JSON. The second is via RPC `dump_consensus_state`.\n\nCase 1, which should not be hit in production, will eventually hit the deadlock in most goroutines, effectively halting the node.\n\nIn case 2, only the data structures related to the first peer will be deadlocked, together with the thread(s) dealing with the RPC request(s). This means that only one of the channels of communication to the node's peers will be blocked. Eventually the peer will timeout and excluded from the list (typically after 2 minutes). The goroutines involved in the deadlock will not be garbage collected, but they will not interfere with the system after the peer is excluded.\n\nThe theoretical worst case for case 2, is a network with only two validator nodes. In this case, each of the nodes only has one `PeerState` struct. If `dump_consensus_state` is called in either node (or both), the chain will halt until the peer connections time out, after which the nodes will reconnect (with different `PeerState` structs) and the chain will progress again. Then, the same process can be repeated.\n\nAs the number of nodes in a network increases, and thus, the number of peer struct each node maintains, the possibility of reproducing the perturbation visible with two nodes decreases. Only the first `PeerState` struct will deadlock, and not the others (RPC `dump_consensus_state` accesses them in a for loop, so the deadlock at the first iteration causes the rest of the iterations of that \"for\" loop to never be reached).\n\nThis regression was fixed in versions 0.34.29 and 0.37.2. Some workarounds are available. For case 1 (hitting the deadlock via logs), either don't set the log output to \"json\", leave at \"plain\", or don't set the consensus logging module to \"debug\", leave it at \"info\" or higher. For case 2 (hitting the deadlock via RPC `dump_consensus_state`), do not expose `dump_consensus_state` RPC endpoint to the public internet (e.g., via rules in one's nginx setup).",
          "Severity": "MEDIUM",
          "CweIDs": [
            "CWE-401",
            "CWE-770"
          ],
          "CVSS": {
            "ghsa": {
              "V3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
              "V3Score": 5.3
            },
            "nvd": {
              "V3Vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
              "V3Score": 5.3
            }
          },
          "References": [
            "https://github.com/advisories/GHSA-mvj3-qrqh-cjvr",
            "https://github.com/cometbft/cometbft/pull/524",
            "https://github.com/cometbft/cometbft/pull/863",
            "https://github.com/cometbft/cometbft/pull/865",
            "https://github.com/cometbft/cometbft/security/advisories/GHSA-mvj3-qrqh-cjvr",
            "https://nvd.nist.gov/vuln/detail/CVE-2023-34450"
          ],
          "PublishedDate": "2023-07-03T17:15:00Z",
          "LastModifiedDate": "2023-07-17T18:56:00Z"
        },
        {
          "VulnerabilityID": "GHSA-qfc5-6r3j-jj22",
          "PkgName": "github.com/cosmos/cosmos-sdk",
          "InstalledVersion": "v0.45.16",
          "Layer": {
            "Digest": "sha256:b8a1780f82ad325be555dca397d200f52a967c999847eaf12cd6c3d0f2013ee9",
            "DiffID": "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
          },
          "SeveritySource": "ghsa",
          "PrimaryURL": "https://github.com/advisories/GHSA-qfc5-6r3j-jj22",
          "DataSource": {
            "ID": "ghsa",
            "Name": "GitHub Security Advisory Go",
            "URL": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"
          },
          "Title": "Go package github.com/cosmos/cosmos-sdk module x/crisis does NOT cause chain halt",
          "Description": "# x/crisis does NOT cause chain halt\n\n### Impact\nIf an invariant check fails on a Cosmos SDK network and a transaction is sent to the `x/crisis` module to halt the chain, the chain does not halt. All versions of the `x/crisis` module is affected on all versions of the Cosmos SDK.\n\n### Details\nThe `x/crisis` module is supposed to allow anyone to halt a chain in the event of a violated invariant by sending a `MsgVerifyInvariant` with the name of the invariant. Processing this message is supposed to cause the nodes to panic. However, because the panic is within a transaction, it is caught by the SDK’s built-in panic-recovery machinery and just treated as a normal “invalid” transaction (ie. it returns a non-zero abci Code). Thus the `x/crisis` transactions don’t actually cause chains to halt. If there is an invariant violation, it can be confirmed with an `x/crisis` transaction, but it won’t cause any nodes to halt, they will just continue processing blocks.\n\nThat said, any node running with `start --inv-check-period X` will actually panic when it runs the periodic check (though it will still not panic just by processing an `x/crisis` transaction). Since this panic is located in EndBlock, it is not caught by the panic-recovery machinery and does actually crash the node. Presumably few if any nodes actually run with this in production because of how long the invariant checks take, and this runs all of them every `X` blocks.\n\n### Patches\nNo patches will be released.\n\nThe `x/crisis` module was originally intended to allow chains to halt rather than continue with some unknown behaviour in the case of an invariant violation (safety over liveness). However, as chains mature, and especially as the potential [cost of halting increases](https://github.com/osmosis-labs/osmosis/issues/570), chains should consider carefully what invariants they really want to halt for, and what invariants are just sort of helpful sanity checks, but may not be worth halting for.\n\nIn some cases, chains have already broken the invariant calculations but have dealt with the consequences off-chain or during development. Halting these chains would be counter-productive.\n\nThe SDK team is working on new modules that allow chain developers to fine-tune the chain invariants and the necessary actions.\n\nHence, the decision was made that the `x/crisis` module will not be patched for chain halts. The module will be deprecated when new modules take over its responsibilities.\n\n### Workarounds\nIn case of a valid invariant check failure that requires a chain halt, the network validators are encouraged to coordinate off-chain for network halts. This has been an already established process for security patches.\n\n### References\nSDK developer epic about invariant checking: https://github.com/cosmos/cosmos-sdk/issues/15706\nPublic report: https://github.com/cosmos/cosmos-sdk/issues/15325",
          "Severity": "LOW",
          "References": [
            "https://github.com/advisories/GHSA-qfc5-6r3j-jj22",
            "https://github.com/cosmos/cosmos-sdk/issues/15325",
            "https://github.com/cosmos/cosmos-sdk/issues/15706",
            "https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-qfc5-6r3j-jj22"
          ]
        },
        {
          "VulnerabilityID": "GHSA-w5w5-2882-47pc",
          "PkgName": "github.com/cosmos/cosmos-sdk",
          "InstalledVersion": "v0.45.16",
          "Layer": {
            "Digest": "sha256:b8a1780f82ad325be555dca397d200f52a967c999847eaf12cd6c3d0f2013ee9",
            "DiffID": "sha256:e7768a73d676168e704a4d4334b34dccfdaa81bcdb931a6d494b7c7f9c4fe1be"
          },
          "SeveritySource": "ghsa",
          "PrimaryURL": "https://github.com/advisories/GHSA-w5w5-2882-47pc",
          "DataSource": {
            "ID": "ghsa",
            "Name": "GitHub Security Advisory Go",
            "URL": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"
          },
          "Title": "github.com/cosmos/cosmos-sdk's x/crisis does not charge ConstantFee",
          "Description": "# x/crisis does not charge ConstantFee\n### Impact\nIf a transaction is sent to the `x/crisis` module to check an invariant, the ConstantFee parameter of the chain is NOT charged. All versions of the `x/crisis` module are affected on all versions of the Cosmos SDK.\n\n### Details\nThe `x/crisis` module is supposed to allow anyone to halt a chain in the event of a violated invariant by sending a `MsgVerifyInvariant` with the name of the invariant. Processing this message takes extra processing power hence a `ConstantFee` was introduced on the chain that is charged as extra from the reporter for the extra computational work. This is supposed to avert spammers on the chain making nodes do extra computations using this transaction. By not charging the `ConstantFee`, the transactions related to invariant checking are relatively cheaper compared to the computational need and other transactions.\n\nThat said, the submitter still has to pay the transaction fee to put the transaction on the network, hence using this weakness for spamming is limited by the usual mechanisms.\n\nSynthetic testing showed up to a 20% increase in CPU usage on a validator node that is spammed by hundreds of `MsgVerifyInvariant` messages which still makes this an expensive operation to carry out on a live blockchain network.\n\n### Patches\nThe `ConstantFee` charge of the `x/crisis` module will either be fixed or disabled in an upcoming regular release of the Cosmos SDK.\n\nThe `x/crisis` module was originally intended to allow chains to halt rather than continue with some unknown behavior in the case of an invariant violation (safety over liveness). However, as chains mature, and especially as the potential [cost of halting increases](https://github.com/osmosis-labs/osmosis/issues/570), chains should consider carefully what invariants they really want to halt for, and what invariants are just sort of helpful sanity checks.\n\nThe SDK team is working on new modules that allow chain developers to fine-tune the chain invariants and the necessary actions.\n\nHence, the decision was made that the `x/crisis` module will be deprecated when new modules take over its responsibilities.\n\n### Workarounds\nThere is no workaround posted. Validators are advised to leave some extra computing room on their servers for possible spamming scenarios. (This is a good measure in any case.)\n\n### References\nSDK developer epic about invariant checking: https://github.com/cosmos/cosmos-sdk/issues/15706\n",
          "Severity": "LOW",
          "References": [
            "https://github.com/advisories/GHSA-w5w5-2882-47pc",
            "https://github.com/cosmos/cosmos-sdk/issues/15706",
            "https://github.com/cosmos/cosmos-sdk/security/advisories/GHSA-w5w5-2882-47pc"
          ]
        }
      ]
    }
  ]
}
